<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[夜阳's Blog]]></title>
  <subtitle><![CDATA[记录点滴　|　仰望星空，脚踏实地]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jakezy.com//"/>
  <updated>2015-08-08T04:48:16.270Z</updated>
  <id>http://jakezy.com//</id>
  
  <author>
    <name><![CDATA[Jake Z]]></name>
    <email><![CDATA[zyseap@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ArrayBlockingQueue]]></title>
    <link href="http://jakezy.com/2015/08/08/ArrayBlockingQueue/"/>
    <id>http://jakezy.com/2015/08/08/ArrayBlockingQueue/</id>
    <published>2015-08-08T04:47:55.000Z</published>
    <updated>2015-08-08T04:48:16.270Z</updated>
    <content type="html"><![CDATA[<h3 id="实现方式：">实现方式：</h3><ul>
<li>ArrayBlockingQueue是基于数组、FIFO、线程安全的集合类，可实现指定时间的阻塞读写，且容量可限制</li>
</ul>
<h4 id="ArrayBlockingQueue(int)">ArrayBlockingQueue(int)</h4><ul>
<li>无默认构造器，传入参数即为创建的对象数组的大小，同时初始化锁和两个锁上的Condition，一个为notEmpty，一个为notFull</li>
</ul>
<h4 id="offer(E,_long,_TimeUnit)">offer(E, long, TimeUnit)</h4><ul>
<li>插入元素至数组尾部。若数组已满，进入等待，直到被唤醒、到达指定时间或当前线程被中断<blockquote>
<p>先将指定时间转换为纳秒，加锁<br>  若数组未满，将对象插入数组<br>  若数组已满且已超过指定时间，返回false<br>  若数组已满且未超过指定时间，调用notFull condition的awaitNanos方法进行等待</p>
<ul>
<li>若被唤醒或超时，则继续判断数组是否已满</li>
<li>若线程被interrupt，直接抛出InterruptedException</li>
</ul>
</blockquote>
</li>
<li>不带时间的offer方法在数组满时不进入等待，直接返回false</li>
<li>也可选择调用put方法，在数组满时一直等待，直到数组不为空或线程被interrupt</li>
</ul>
<h4 id="pool(E,_long,_TimeUnit)">pool(E, long, TimeUnit)</h4><ul>
<li>获取队列中的第一个元素，若队列中没有元素，则进入等待，直到被唤醒、到达指定时间或当前线程被中断<blockquote>
<p>先将指定时间转换为纳秒，加锁<br>若数组中元素个数不为0，则从当前对象数组中获取最后一个元素，将该位置上元素置null<br>若数组中元素个数为0，</p>
<ul>
<li>若剩余等待时间&lt;0，返回null</li>
<li>若剩余等待时间&gt;0，调用notEmpty condition的awaitNanos方法进行等待<blockquote>
<p>若被唤醒或超时，则判断数组中元素个数是否不为0<br>若线程被interrupt，则抛出interruptedException</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>不带时间的poll方法在数组中元素个数为0时不进入等待，直接返回null</li>
<li>也可选择调用take方法，在数组空时一直等待，直到直到数组不为空或线程被interrupt</li>
</ul>
<h4 id="iterator()">iterator()</h4><ul>
<li>加锁，创建Itr对象实例，创建时首先获取当前数组元素尾部的index及尾部的元素，调用完后释放锁</li>
<li>调用Itr的next方法：加锁，获取Itr中的nextItem，增加需要获取的下一元素index，并检查下一元素是否存在<blockquote>
<p>若存在，则获取并赋值到nextItem；<br>若不存在，则将nextIndex设置为-1，nextItem设置为null</p>
</blockquote>
</li>
</ul>
<h3 id="小结：">小结：</h3><ul>
<li>ArrayBlockingQueue为一个基于固定大小数组、ReentrantLock及Condition实现的可阻塞的先进先出的Queue</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实现方式：">实现方式：</h3><ul>
<li>ArrayBlockingQueue是基于数组、FIFO、线程安全的集合类，可实现指定时间的阻塞读写，且容量可限制</li>
</ul>
<h4 id="ArrayBlockingQueue(int)">Arra]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CopyOnWriteArraySet]]></title>
    <link href="http://jakezy.com/2015/08/08/CopyOnWriteArraySet/"/>
    <id>http://jakezy.com/2015/08/08/CopyOnWriteArraySet/</id>
    <published>2015-08-08T04:45:55.000Z</published>
    <updated>2015-08-08T04:46:34.655Z</updated>
    <content type="html"><![CDATA[<h3 id="实现方式：">实现方式：</h3><ul>
<li>基于CopyOnWriteArrayList实现，唯一不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法</li>
<li>addIfAbsent方法同样采用锁保护，并创建一个新的大小+1的Object数组。遍历当前Object数组，若数组中已有当前元素，则直接返回；若没有，则放入Object数组尾部，并返回</li>
</ul>
<h3 id="小结：">小结：</h3><ul>
<li>CopyOnWriteArraySet在add时每次都要遍历数组，因此性能略低于CopyOnWriteArrayList</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实现方式：">实现方式：</h3><ul>
<li>基于CopyOnWriteArrayList实现，唯一不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法</li>
<li>addIfAbsent方法同样采用锁保护，并创]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CopyOnWriteArrayList]]></title>
    <link href="http://jakezy.com/2015/08/08/CopyOnWriteArrayList/"/>
    <id>http://jakezy.com/2015/08/08/CopyOnWriteArrayList/</id>
    <published>2015-08-08T04:42:02.000Z</published>
    <updated>2015-08-08T04:44:18.195Z</updated>
    <content type="html"><![CDATA[<h3 id="实现方式：">实现方式：</h3><p>CopyOnWriteArrayList是线程安全、读操作时无锁的ArrayList</p>
<h4 id="CopyOnWriteArrayList()">CopyOnWriteArrayList()</h4><ul>
<li>创建大小为0的数组</li>
</ul>
<h4 id="add(E)">add(E)</h4><ul>
<li>无synchronized关键字，通过ReentrantLock保证线程安全</li>
<li>每次都创建一个新的Object数组（数组大小是当前数组大小+1），将之前数组内容复制到新数组，新增加的对象放入数组末尾，最后将新创建的数组对象赋值给全局的数组对象</li>
</ul>
<h4 id="remove(E)">remove(E)</h4><ul>
<li>无synchronized关键字，通过ReentrantLock保证线程安全</li>
<li>首先创建一个比当前数组小1的数组，遍历数组</li>
<li>若找到equals或均为null的元素，则将之后的元素全部赋值给新数组对象，并将引用切换，返回true</li>
<li>若未找到，将当前元素赋值给新数组对象，<br>  （未完。。。）</li>
</ul>
<h4 id="get(int)">get(int)</h4><ul>
<li>无锁，直接获取当前数组对应位置的元素，可能出现读脏数据现象</li>
<li>适合写少读多脏数据影响不大的场景</li>
</ul>
<h4 id="iterator()">iterator()</h4><ul>
<li>创建一个新的COWIterator对象实例，并保存一个当前数组的快照，调用next遍历时仅对此快照数组遍历</li>
</ul>
<h3 id="小结：">小结：</h3><ul>
<li>CopyOnWriteArrayList基于ReentrantLock保证了增加删除元素的互斥，读操作是无锁操作，保证了读的性能</li>
</ul>
<h3 id="与ArrayList性能比较：">与ArrayList性能比较：</h3><ul>
<li>随着元素数量和线程数增加，CopyOnWriteArrayList在增删元素时性能下降明显，但查找元素随着线程数增加，性能比ArrayList好很多</li>
<li>读多写少的并发场景中，CopyOnWriteArrayList比ArrayList更好</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实现方式：">实现方式：</h3><p>CopyOnWriteArrayList是线程安全、读操作时无锁的ArrayList</p>
<h4 id="CopyOnWriteArrayList()">CopyOnWriteArrayList()</h4><ul>
<]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ConcurrentHashMap]]></title>
    <link href="http://jakezy.com/2015/08/08/ConcurrentHashMap/"/>
    <id>http://jakezy.com/2015/08/08/ConcurrentHashMap/</id>
    <published>2015-08-08T04:30:02.000Z</published>
    <updated>2015-08-08T04:44:31.067Z</updated>
    <content type="html"><![CDATA[<h3 id="实现方式：线程安全的HashMap的实现">实现方式：线程安全的HashMap的实现</h3><h4 id="ConcurrentHashMap()">ConcurrentHashMap()</h4><ul>
<li>和HashMap一样，有initialCapacity和loadFactor属性，多了一个concurrencyLevel属性，默认值为16、0.75和16</li>
<li>计算ssize值，传入Segment的newArray方法创建Segment对象数组</li>
<li>计算cap值，为Segment数组创建Segment对象（继承自ReentrantLock）：创建一个指定大小为cap的HashEntry对象数组，threshold=(int)(newTable.length*loadFactor);</li>
</ul>
<h4 id="put(Object_key,_Object_key)">put(Object key, Object key)</h4><ul>
<li>无synchronized关键字</li>
<li>首先判断value是否为null，若为null，抛出NullPointerException</li>
<li>对key.hashCode进行hash操作，得到key的hash值</li>
<li>根据hash值计算并获取对应数组中的Segment对象，调用Segment的put方法完成put操作<blockquote>
<p>Segment的put方法：</p>
<ul>
<li>lock，判断当前存储的对象个数+1后是否大于threshold</li>
<li>若大于，将当前HashEntry数组扩大两倍，之前存储的对象重新hash，转移到新数组中</li>
<li>接下来和HashMap基本一样，hash出来的值与对象数组的大小减1的值进行按位与，得出当前key要存储到数组的位置</li>
<li>寻找对应位置上的HashEntry对象链表是否有key、hash和当前key相同的</li>
<li>若找到，则覆盖其value</li>
<li>否则，则创建新的HashEntry对象，赋值给对应位置的数组对象，并构成链表</li>
<li>释放锁，unlock</li>
</ul>
</blockquote>
</li>
<li>小结：ConcurrentHashMap基于匆促人人参与Level划分多个Segment对key-value存储，避免每次put都锁住整个数组。默认情况下，最佳情况可允许16个线程并发无阻塞地操作集合对象</li>
</ul>
<h4 id="remove(Object_key)">remove(Object key)</h4><ul>
<li>对key.hashCode进行hash操作，得到hash值找到对应的Segment对象，调用Segment的remove方法完成remove操作<blockquote>
<p>Segment的remove方法：</p>
<ul>
<li>lock，hash值与对象数组的大小减1的值进行按位与，获取数组上对应位置的HashEntry对象</li>
<li>遍历HashEntry及其next对象，寻找hash值相等及key equals的HashEntry对象</li>
<li>若找到，重新创建HashEntry链表中位于删除元素之前的所有HashEntry；未找到，返回null</li>
<li>释放锁，unlock</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="get(Object_key)">get(Object key)</h4><ul>
<li>对key.hashCode进行hash操作，得到hash值找到对应的Segment对象，调用Segment的get方法完成get操作<blockquote>
<p>Segment的get方法：</p>
<ul>
<li>判断当前HashEntry对象数组中已存储的对象是否为0，若为0，则直接返回null</li>
<li>hash值与对象数组的大小减1的值进行按位与，获取数组上对应位置的HashEntry对象</li>
<li>遍历HashEntry及其next对象，寻找hash值相等及key equals的HashEntry对象</li>
<li>若找到，获取其value，若value不为null，则返回value</li>
<li>若value为null，则调用readValueUnderLock方法（lock，直接返回HashEntry的value，释放锁）</li>
</ul>
</blockquote>
</li>
<li>小结：<br>  get仅在寻找到的HashEntry的value为null时才加锁，即ConcurrentHashMap在读数据时大部分情况下不采用锁<blockquote>
<p>ConcurrentHashMap一致性的保证：</p>
<ul>
<li>get操作首先通过hash值与对象数组的大小减1的值进行按位与，获取数组上对应位置的HashEntry对象，这个步骤中可能因对象数组大小的改变，及数组上对应位置的HashEntry产生不一致性</li>
<li>对象数组大小的改变只有在put操作时有可能发生，而HashEntry对象数组对应的变量是volatile类型，因此可保证HashEntry数组大小改变时，读操作可看到最新的对象数组大小</li>
<li>put和remove操作进行时都有可能造成HashEntry数组上对应位置的HashEntry发生改变，如get操作获取到HashEntry对象后，有一个put或remove操作完成，此时get操作尚未完成，这时会造成读的不一致，但这种几率非常低</li>
<li>获取到HashEntry对象后，可保证HashEntry对象及其next属性构成的链表上的对象不会改变，因为HashEntry对象中的hash、key及next都是final的，即无法插入一个HashEntry到基于next构建的链表中间或末尾，这样就保证了当获取到HashEntry对象后，其基于next构建的链表不会发生变化</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="containsKey(Object_key)">containsKey(Object key)</h4><ul>
<li>整个步骤和get相同，没有加锁，只是当寻找到有key、hash相等的HashEntry时才返回true，否则返回false<br>keySet().iterator()：</li>
<li>不加锁，遍历每个分段中的HashEntry对象数组，完成集合中所有对象的读取</li>
</ul>
<h3 id="小结：">小结：</h3><ul>
<li>ConcurrentHashMap默认情况下将数据分为16个段存储，各个段持有各自的锁，锁仅用于put和remove等改变集合对象的操作，基于volatile及HashEntry链表的不变性实现读取的不加锁。</li>
<li>没有全局锁，计算size：<ul>
<li>不加锁遍历所有段，读取count及modCount（volatile类型）并统计。</li>
<li>再遍历一次所有段，比较modCount是否改变</li>
<li>若改变，则尝试两次以上动作</li>
<li>若扔有问题，则遍历所有段，分别加锁、计算，释放所有锁</li>
</ul>
</li>
</ul>
<h3 id="和HashMap性能对比：">和HashMap性能对比：</h3><ul>
<li>线程数为10时，ConcurrentHashMap性能提升不明显</li>
<li>线程数50或100时，增加删除元素带来一倍左右的性能提升，查找元素10倍左右性能提升</li>
<li>线程数增长，性能没有出现下降</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实现方式：线程安全的HashMap的实现">实现方式：线程安全的HashMap的实现</h3><h4 id="ConcurrentHashMap()">ConcurrentHashMap()</h4><ul>
<li>和HashMap一样，有initialCapa]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AtomicInteger]]></title>
    <link href="http://jakezy.com/2015/08/08/AtomicInteger/"/>
    <id>http://jakezy.com/2015/08/08/AtomicInteger/</id>
    <published>2015-08-08T04:01:02.000Z</published>
    <updated>2015-08-08T04:44:37.310Z</updated>
    <content type="html"><![CDATA[<h3 id="实现方式">实现方式</h3><p>AtomicInteger是一个支持原子操作的Integer类<br>用AtomicInteger实现的顺序id获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="incrementAndGet()">incrementAndGet()</h4><p>简化后的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Atomically increments by one the current value.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> the updated value</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无限循环直到value设置成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 前两步非线程安全，因此不能直接返回next</span></span><br><span class="line">            <span class="comment">// 因为此时可能会有其他线程已经对current进行了更改，所以要调用compareAndSet判断</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Atomically sets the value to the given updated value</span><br><span class="line">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> expect the expected value</span><br><span class="line">     * <span class="doctag">@param</span> update the new value</span><br><span class="line">     * <span class="doctag">@return</span> true if successful. False return indicates that</span><br><span class="line">     * the actual value was not equal to the expected value.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CAS有3个操作数：内存值value，要跟内存值做比较的值expect和新值update</span></span><br><span class="line">        <span class="comment">// 若value==expect，则令value=update，返回true；否则，返回false</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不使用compareAndSet可能出现的异常：</p>
<ol>
<li>A线程执行get()操作，获取current值（假设为1）</li>
<li>B线程执行get()操作，获取current值（为1）</li>
<li>B线程执行next = current + 1操作，next = 2</li>
<li>A线程执行next = current + 1操作，next = 2</li>
</ol>
</blockquote>
<p>compareAndSet调用native方法compareAndSwapInt，它基于CAS原语实现，由CPU比较内存位置上的值是否为当前值，若是则将其设置为next，否则返回false<br>基于CAS的操作可认为是无阻塞的，且CAS原语性能会好于同步锁</p>
<h5 id="基于原子类的CAS操作自主实现无阻塞操作">基于原子类的CAS操作自主实现无阻塞操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * CAS操作判断当前方法是否已经初始化</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean inited = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inited.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"已初始化："</span> + flag);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化操作</span></span><br><span class="line">        System.out.println(<span class="string">"未初始化："</span> + flag);</span><br><span class="line">        flag++;</span><br><span class="line">        System.out.println(<span class="string">"初始化完毕："</span> + flag);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="实现方式">实现方式</h3><p>AtomicInteger是一个支持原子操作的Integer类<br>用AtomicInteger实现的顺序id获取：<br><figure class="highlight java"><table><tr><td class]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 14]]></title>
    <link href="http://jakezy.com/2015/08/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-14/"/>
    <id>http://jakezy.com/2015/08/08/Leetcode刷题记录-14/</id>
    <published>2015-08-08T02:50:49.000Z</published>
    <updated>2015-08-08T02:50:14.574Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_II"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_III"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_IV"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to Buy and Sell Stock IV</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.util.ConcurrentModificationException出现原因及解决办法]]></title>
    <link href="http://jakezy.com/2015/08/06/java.util.ConcurrentModificationException%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://jakezy.com/2015/08/06/java.util.ConcurrentModificationException出现原因及解决办法/</id>
    <published>2015-08-06T14:06:21.000Z</published>
    <updated>2015-08-06T14:08:21.925Z</updated>
    <content type="html"><![CDATA[<p>待补充</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>待补充</p>
]]>
    </summary>
    
      <category term="问题记录" scheme="http://jakezy.com/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 13]]></title>
    <link href="http://jakezy.com/2015/08/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-13/"/>
    <id>http://jakezy.com/2015/08/06/Leetcode刷题记录-13/</id>
    <published>2015-08-06T14:01:33.000Z</published>
    <updated>2015-08-06T14:14:01.690Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a></li>
<li><a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="external">Majority Element II</a></li>
<li><a href="http://www.lintcode.com/en/problem/majority-number-iii/" target="_blank" rel="external">Majority Number III</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Majority_Element"><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a></h2><p>思路：<br>多数投票算法：</p>
<ol>
<li>若count==0，则将result设为数组当前元素num，count++</li>
<li>若result和现在数组元素num相同，则count++，否则count–</li>
<li>重复上述两步，直到扫描完数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                result = num;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == num) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Majority_Element_II"><a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="external">Majority Element II</a></h2><p>思路：<br>出现次数大于n/3的数最多两个，最少一个也没有<br>同样利用多数投票算法，但此时有两个候选元素<br>注意两个候选元素相同的情况，最后要再重新统计一遍两个候选元素的出现次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                number[<span class="number">0</span>] = num;</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; number[<span class="number">0</span>] != num) &#123;</span><br><span class="line">                number[<span class="number">1</span>] = num;</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == number[<span class="number">0</span>]) &#123;</span><br><span class="line">                    count[<span class="number">0</span>]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == number[<span class="number">1</span>]) &#123;</span><br><span class="line">                    count[<span class="number">1</span>]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count[<span class="number">0</span>]--;</span><br><span class="line">                    count[<span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[<span class="number">0</span>] = count[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == number[<span class="number">0</span>])</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (num == number[<span class="number">1</span>])</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">0</span>] &gt; nums.length / <span class="number">3</span>)</span><br><span class="line">            result.add(number[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (count[<span class="number">1</span>] &gt; nums.length / <span class="number">3</span> &amp;&amp; number[<span class="number">0</span>] != number[<span class="number">1</span>])</span><br><span class="line">            result.add(number[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Majority_Number_III"><a href="http://www.lintcode.com/en/problem/majority-number-iii/" target="_blank" rel="external">Majority Number III</a></h2><p>思路：<br>题目明确说明只有一个众数<br>利用多数投票算法，HashMap保存k个候选元素</p>
<ol>
<li>若HashMap中不存在num，则将num置入HashMap，对应value=1</li>
<li>若HashMap中存在num，则将对应value++</li>
<li>若HashMap的size等于k，则每个元素value–，若此时value=0，则从HashMap中删除</li>
<li>重复上述两步，直到扫描完数组</li>
<li>最后重新统计一遍HashMap中候选元素的出现次数</li>
</ol>
<p>可能出现的问题：<br><a href="http://jakezy.com/2015/08/06/java.util.ConcurrentModificationException%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">HashMap删除元素时报错：java.util.ConcurrentModificationException</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> nums: A list of integers</span><br><span class="line">     * <span class="doctag">@param</span> k: As described</span><br><span class="line">     * <span class="doctag">@return</span>: The majority number</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">        List&lt;Integer&gt; remove = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer key : keySet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(key) == <span class="number">1</span>) &#123;</span><br><span class="line">                remove.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(key, map.get(key) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer key : remove) &#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityNumber</span><span class="params">(ArrayList&lt;Integer&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(num)) &#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt;= k) &#123;</span><br><span class="line">                removeKey(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == key)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; times) &#123;</span><br><span class="line">                times = count;</span><br><span class="line">                result = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/majority-element/">Majority Element</a></li>
<li><a href="https://leetcode.com/problems/majority-element-ii/">Majority Element II</a></li>
<li><a href="http://www.lintcode.com/en/problem/majority-number-iii/">Majority Number III</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 12]]></title>
    <link href="http://jakezy.com/2015/08/05/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-12/"/>
    <id>http://jakezy.com/2015/08/05/Leetcode刷题记录-12/</id>
    <published>2015-08-05T03:16:58.000Z</published>
    <updated>2015-08-06T14:05:06.271Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">Single Number</a></li>
<li><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="external">Single Number II</a></li>
<li><a href="http://www.lintcode.com/en/problem/single-number-iii/" target="_blank" rel="external">Single Number III</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Single_Number"><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">Single Number</a></h2><p>思路：<br>异或：不进位加法（相同为0，相异为1）<br>a ^ a = 0<br>a ^ 0 = a<br>a ^ b = c =&gt; a ^ c = b, b ^ c = a</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Single_Number_II"><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="external">Single Number II</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// count[]记录二进制每一位上1出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">// nums[j]右移i位再&amp;1的结果即为nums[j]第i位的二进制值</span></span><br><span class="line">                <span class="comment">// count[i]即为第i位1出现的次数</span></span><br><span class="line">                count[i] += (nums[j] &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// count[i]%3即为res在该位的二进制值</span></span><br><span class="line">            res |= (count[i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Single_Number_III"><a href="http://www.lintcode.com/en/problem/single-number-iii/" target="_blank" rel="external">Single Number III</a></h2><p>思路：<br>使用n&amp;-n把a和b两个只出现一次的数区分开<br>n&amp;-n结果只保留n的二进制中第一个1出现的位置<br>n&amp;-n = n&amp;~(n-1)</p>
<pre><code>例如：
<span class="keyword">n</span>    = 010100
-<span class="keyword">n</span>   = 101100
<span class="keyword">n</span>&amp;-<span class="keyword">n</span> = 000100
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">singleNumberIII</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            temp ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp &amp; -temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp &amp; A[i]) == <span class="number">0</span>)</span><br><span class="line">                res[<span class="number">0</span>] ^= A[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[<span class="number">1</span>] ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = Arrays.asList(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/single-number/">Single Number</a></li>
<li><a href="https://leetcode.com/problems/single-number-ii/">Single Number II</a></li>
<li><a href="http://www.lintcode.com/en/problem/single-number-iii/">Single Number III</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[集合包]]></title>
    <link href="http://jakezy.com/2015/08/04/%E9%9B%86%E5%90%88%E5%8C%85/"/>
    <id>http://jakezy.com/2015/08/04/集合包/</id>
    <published>2015-08-04T15:21:57.000Z</published>
    <updated>2015-08-08T04:01:38.514Z</updated>
    <content type="html"><![CDATA[<h1 id="JDK类库：集合包（java-util）"><strong>JDK类库：集合包（java.util）</strong></h1><p><img src="http://ww2.sinaimg.cn/large/965a04dfgw1euqy0ir7gyj20i806y3zg.jpg" alt="集合包"></p>
<hr>
<h2 id="Collection"><strong>Collection</strong></h2><p>Collection接口：单对象存储的集合对象</p>
<hr>
<h3 id="List"><strong>List</strong></h3><p>允许元素重复</p>
<h4 id="ArrayList"><strong>ArrayList</strong></h4><p>实现方式：数组方式存放对象</p>
<ul>
<li>创建：ArrayList(int)<br>  实例化一个大小为intitailCapacity（默认为10）的Object数组，并赋值给elementData</li>
<li>插入对象：add(E)<ul>
<li>ArrayList已有元素数量+1，赋值给minCapacity</li>
<li>若minCapacity&gt;Object.length，则将Object赋给一个数组对象，产生一个新的数组容量值（大小为当前Object.length*1.5+1）</li>
<li>若新的Object.length仍小于minCapacity，则以minCapacity作为新容量值</li>
<li>调用Arrays.copyOf生成新的数组对象，若想调整容量的增长策略，可继承ArrayList并覆盖ensureCapacity方法</li>
<li>Arrays.copyOf实现方法：（未完。。。）</li>
</ul>
</li>
<li>删除对象：remove(E)</li>
<li>获取单个对象：get(int)</li>
<li>遍历对象：iterator()</li>
<li>判断对象是否存在：contains(E)</li>
</ul>
<p>注意要点：</p>
<ul>
<li>ArrayList基于数组实现，无容量限制</li>
<li>插入元素时可能要扩容，删除时不会减少容量（可调用trimToSize()缩小容量）</li>
<li>查找元素时要遍历数组，对于非null元素采用equals方式查找</li>
<li>ArrayList是非线程安全的</li>
</ul>
<h4 id="LinkedList"><strong>LinkedList</strong></h4><p>实现方式：基于双向链表，Entry类代表集合中的元素</p>
<ul>
<li>创建：LinkedList()</li>
<li>插入对象：add(E)<ul>
<li>创建新的Entry对象，修改相邻两个元素的属性</li>
</ul>
</li>
<li>删除对象：remove(E)</li>
<li>获取单个对象：get(int)<ul>
<li>判断传入的index是否在size范围内，抛出IndexOutOfBoundsException</li>
<li>判断index是否小于size的一半，若小于，则从头向后找，否则从尾部向前找</li>
</ul>
</li>
<li>遍历对象：iterator()</li>
<li>判断对象是否存在：contains(E)</li>
</ul>
<p>注意要点：</p>
<ul>
<li>LinkedList基于双向链表实现</li>
<li>插入元素时要创建新的Entry对象，并修改前后元素的引用</li>
<li>查找删除元素时要遍历链表</li>
<li>LinkedList是非线程安全的</li>
</ul>
<h4 id="Vector"><strong>Vector</strong></h4><p>实现方式：Vector和ArrayList一样，基于Object数组实现</p>
<ul>
<li>创建：Vector()<ul>
<li>默认创建大小为10的Object数组，将capacityIncrement设置为0</li>
</ul>
</li>
<li>插入对象：add(E)<ul>
<li>add方法是线程安全的，有synchronized关键字</li>
<li>扩大数组方式：<ul>
<li>若capacityIncrement&gt;0，则将Object数组大小扩大为现有size+capacityIncrement</li>
<li>若capacityIncrement≤0，则将Object数组大小扩大为现有size的两倍</li>
</ul>
</li>
<li>其他和ArrayList基本相同</li>
</ul>
</li>
<li>删除对象：remove(E)<ul>
<li>有synchronized关键字，实现和ArrayList完全相同</li>
</ul>
</li>
<li>获取单个对象：get(int)<ul>
<li>有synchronized关键字，实现和ArrayList完全相同</li>
</ul>
</li>
<li>遍历对象：iterator()<ul>
<li>实现和ArrayList完全相同</li>
</ul>
</li>
<li>判断对象是否存在：contains(E)<ul>
<li>indexOf方法有synchronized关键字</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>Vector是基于Synchronized实现的线程安全的ArrayList</li>
<li>容量扩充机制和ArrayList不同，可通过传入capacityIncrement控制容量扩充</li>
</ul>
<h4 id="Stack"><strong>Stack</strong></h4><p>实现方式：Stack继承自Vector，在Vector基础上实现了LIFO的弹出及压入操作</p>
<ul>
<li>push：<ul>
<li>调用Vector中的addElement</li>
</ul>
</li>
<li>pop：<ul>
<li>调用peek获取元素，同时删除数组的最后一个元素</li>
</ul>
</li>
<li>peek：<ul>
<li>获取当前Object数组大小，并获取数组最后一个元素</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>Stack基于Vector实现，支持LIFO（后进先出）</li>
</ul>
<hr>
<h3 id="Set"><strong>Set</strong></h3><p>不允许元素重复<br>基于HashMap实现</p>
<h4 id="HashSet"><strong>HashSet</strong></h4><p>实现方式：Set接口的实现，基于HashMap实现</p>
<ul>
<li>创建：HashSet(int)<ul>
<li>创建一个HashMap对象</li>
</ul>
</li>
<li>插入对象：add(E)<ul>
<li>调用HashMap的put(Object, Object)方法</li>
</ul>
</li>
<li>删除对象：remove(E)<ul>
<li>调用HashMap的remove(E)方法</li>
</ul>
</li>
<li>判断对象是否存在：contains(E)<ul>
<li>调用HashMap的containsKey(E)方法</li>
</ul>
</li>
<li>遍历对象：iterator()<ul>
<li>调用HashMap的keySet的iterator方法</li>
<li>不支持get(int)获取单个对象，只能通过iterator方法获取</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>HashSet基于HashMap实现，无容量限制</li>
<li>HashSet是非线程安全的</li>
</ul>
<h4 id="TreeSet"><strong>TreeSet</strong></h4><p>实现方式：TreeSet基于TreeMap实现，TreeSet和HashSet主要不同在于TreeSet对于排序的支持（如传入Comparator实现、descendingSet及descendingIterator等）</p>
<ul>
<li>创建：TreeSet(int)<ul>
<li>创建一个TreeMap对象</li>
</ul>
</li>
<li>插入对象：add(E)<ul>
<li>调用TreeMap的put(Object, Object)方法，要增加的元素作为key，之前已创建的一个final的Object对象作为value</li>
</ul>
</li>
<li>删除对象：remove(E)<ul>
<li>调用TreeMap的remove(Object)方法</li>
</ul>
</li>
<li>遍历对象：iterator()<ul>
<li>调用TreeMap的navigableKeySet的iterator方法</li>
<li>不支持get(int)获取单个对象，只能通过iterator方法获取</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>TreeSet基于TreeMap实现，支持排序</li>
<li>TreeSet是非线程安全的</li>
</ul>
<hr>
<h2 id="Map"><strong>Map</strong></h2><p>Map接口：key-value的集合对象</p>
<hr>
<h4 id="HashMap"><strong>HashMap</strong></h4><p>实现方式：</p>
<ul>
<li>创建：HashMap()<ul>
<li>loadFactor=0.75，threshold=12，创建大小为16的Entry对象数组</li>
<li>若传入初始容量值initialCapacity，则capacity大小为大于initialCapacity的2的倍数</li>
</ul>
</li>
<li>插入对象：put(Object key, Object value)<ul>
<li>key为null时：<ul>
<li>基于Entry的next属性遍历，若存在key，则赋值其value，否则头插法创建新Entry对象</li>
</ul>
</li>
<li>key不为null时：<ul>
<li>先获取key本身的hashCode，再对hashCode做hash操作</li>
<li>hash出来的值与Entry对象数组的大小减1的值进行按位与，得出当前key要存储到数组的位置</li>
<li>获取数组对应的Entry对象，调用Entry的next遍历，寻找hash值和计算出的hash值相等，且key相等或equals的Entry对象</li>
<li>若找到，则替换Entry对象的值，完成put操作，并返回旧的值</li>
<li>否则，则向对应的数组位置利用头插法增加新的Entry对象（hash冲突使用链表法解决）</li>
</ul>
</li>
<li>扩容机制：插入后Entry数组中已用大小≥threshold，则将Entry数组扩大为当前大小的两倍，扩大时对当前Entry对象数组中的元素重新hash，并填充数组，最后重新设置threshold值</li>
</ul>
</li>
<li>获取单个对象：get(Object key)<ul>
<li>key为null时：<ul>
<li>获取数组中第一个Entry对象，基于next遍历，查找key为null的Entry对象，若找到，返回Entry的value，否则返回null</li>
</ul>
</li>
<li>key不为null时：<ul>
<li>对key进行hash和按位与操作，找到对应的存储位置</li>
<li>获取此位置对应的Entry对象，基于next遍历，查找hash值和计算出的hash值相等，且key相等或equals的Entry对象，若找到，返回其value，否则返回null</li>
</ul>
</li>
</ul>
</li>
<li>删除对象：remove(Object key)<ul>
<li>和get类似，找到匹配的key后，若数组上的元素等于key，则将数组元素的值设为其next元素的值；若数组上的元素不等于key，则对链表遍历，直到找到匹配的key或链表尾</li>
</ul>
</li>
<li>判断对象是否存在：contains(Object key)<ul>
<li>调用getEntry方法，getEntry过程和get基本相同，只是在找到匹配的key后直接返回Entry对象，而containsKey判断返回的对象是否为null，返回true/false</li>
</ul>
</li>
<li>遍历对象：keySet()<ul>
<li>调用keySet后会返回一个HashMap中的KeySet对象实例</li>
<li>调用iterator时返回一个KeyIterator对象实例</li>
<li>调用next时，遍历整个数组及Entry对象的链表</li>
<li>HashMap遍历时无法保证顺序</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>HashMap采用数组方式存储key-value构成的Entry对象，无容量限制</li>
<li>HashMap基于key hash寻找Entry对象存放到数组的位置，hash冲突采用链表的方式解决</li>
<li>插入元素时可能会扩大数组容量，此时需要重新计算hash并复制对象到新的数组</li>
<li>HashMap是非线程安全的，并发场景中可能在执行get时进入死循环，将CPU消耗到100%</li>
<li>并发场景中推荐使用并发包中的ConcurrentHashMap</li>
</ul>
<h4 id="TreeMap"><strong>TreeMap</strong></h4><p>实现方式：支持排序的Map实现</p>
<ul>
<li>创建：TreeMap()<ul>
<li>将comparator置为null，也可使用带Comparator参数的构造器</li>
</ul>
</li>
<li>插入对象：put(Object key, Object value)<ul>
<li>先判断root是否为null</li>
<li>root为null：创建新的Entry对象，赋值给root</li>
<li>root不为null：<ul>
<li>若传入了指定的Comparator实现，则基于红黑树的方式遍历，基于comparator比较key应在树的左边还是右边<ul>
<li>若找到相等的key，则直接替换其value，并返回</li>
<li>若未找到相等的key，则一直找到结点为null的元素</li>
</ul>
</li>
<li>若Comparator实现为null，则判断key是否为null，若key为null则抛出NullPointerException<br>（未完）</li>
</ul>
</li>
<li>TreeMap基于红黑树实现，因此要求一定要有key比较的方法，传入Comparator实现或key对象实现Comparable接口</li>
</ul>
</li>
<li>获取单个对象：get(Object key)<ul>
<li>TreeMap查找key时是红黑树查找过程，从根开始往下比较，一直找到相等的key，并返回其value</li>
</ul>
</li>
<li>删除对象：remove(Object key)<ul>
<li>首先调用getEntry方法，然后将Entry从红黑树删除，并调整树上相关结点</li>
</ul>
</li>
<li>判断对象是否存在：contains(Object key)<ul>
<li>调用getEntry方法，判断返回的Entry对象是否为null，返回true/false</li>
</ul>
</li>
<li>遍历对象：keySet()<ul>
<li>调用keySet后返回TreeMap的内部类KeySet对象的实例，iterator遍历从根开始，基于红黑树顺序完成</li>
</ul>
</li>
</ul>
<p>注意要点：</p>
<ul>
<li>TreeMap基于红黑树实现，无容量限制</li>
<li>TreeMap是非线程安全的</li>
</ul>
<p>（整理自<a href="http://book.douban.com/subject/4848587/" target="_blank" rel="external">分布式Java应用</a>）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="JDK类库：集合包（java-util）"><strong>JDK类库：集合包（java.util）</strong></h1><p><img src="http://ww2.sinaimg.cn/large/965a04dfgw1euqy0ir7gyj20i80]]>
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK类库]]></title>
    <link href="http://jakezy.com/2015/08/04/JDK%E7%B1%BB%E5%BA%93/"/>
    <id>http://jakezy.com/2015/08/04/JDK类库/</id>
    <published>2015-08-04T15:14:56.000Z</published>
    <updated>2015-08-08T04:33:27.739Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/965a04dfgw1euqz5bkuvrj20ix0ga41f.jpg" alt="JDK类库"></p>
<a id="more"></a>
<hr>

<style type="text/css">
h2, h3, h4, h5, h6 {
  margin: 0 0 0 0;
}
h3, h4 {
  font-size: 16px;
  font-weight: normal;
}
</style>

<h1 id="集合包">集合包</h1><h2 id="Collection">Collection</h2><ul>
<li><h3 id="List">List</h3><h4 id="[ArrayList]">[ArrayList]</h4><h4 id="[LinkedList]">[LinkedList]</h4><h4 id="[Vector]">[Vector]</h4><h4 id="[Stack]">[Stack]</h4></li>
<li><h3 id="Set">Set</h3><h4 id="[HashSet]">[HashSet]</h4><h4 id="[TreeSet]">[TreeSet]</h4></li>
</ul>
<h2 id="Map">Map</h2><ul>
<li><h3 id="[HashMap]">[HashMap]</h3></li>
<li><h3 id="[TreeMap]">[TreeMap]</h3></li>
</ul>
<p>Collection接口：单对象存储的集合对象</p>
<ul>
<li>List：允许元素重复</li>
<li>Set：不允许元素重复，基于HashMap实现</li>
</ul>
<p>Map接口：key-value的集合对象</p>
<p>随着元素数量的上升（1000以上），List实现方式查找和删除元素时性能下降较严重（查找时遍历整个集合），Set、Map基本不受元素数量影响</p>
<p>TreeSet基于TreeMap实现，TreeMap删除时需排序</p>
<p>实际使用时</p>
<ol>
<li><p>根据功能需求选择List、Set或Map：<br> List：允许重复元素的单个对象集合场景<br> Set：不允许重复元素的单个对象集合场景<br> Map：key-value结构的集合场景，读远比插入删除频繁</p>
</li>
<li><p>选择相应的实现类<br> ArrayList：要通过位置来读取元素的场景（数组）<br> LinkedList：要头尾操作及插入指定位置的场景（双向链表）<br> Vector：线程安全的ArrayList场景<br> Stack：线程安全的LIFO场景</p>
<p> HashSet：无排序要求的非重复元素存放<br> TreeSet：要排序的非重复元素存放</p>
<p> HashMap：大部分key-value存取场景<br> TreeMap：要排序的key-value存取场景</p>
</li>
<li><p>根据场景中需要存储的数据量、操作、并发量进行相应性能测试，若无法满足性能要求，则需自行实现或选择并发包中的集合类</p>
</li>
</ol>
<p><hr></p>
<h1 id="并发包">并发包</h1><ul>
<li><h4 id="[ConcurrentHashMap]">[ConcurrentHashMap]</h4></li>
<li><h4 id="[CopyOnWriteArrayList]">[CopyOnWriteArrayList]</h4></li>
<li><h4 id="[CopyOnWriteArraySet]">[CopyOnWriteArraySet]</h4></li>
<li><h4 id="[ArrayBlockingQueue]">[ArrayBlockingQueue]</h4></li>
<li><h4 id="AtomicInteger"><a href="http://jakezy.com/2015/08/08/AtomicInteger/">AtomicInteger</a></h4></li>
<li><h4 id="[ThreadPoolExecutor]">[ThreadPoolExecutor]</h4></li>
<li><h4 id="[Executors]">[Executors]</h4></li>
<li><h4 id="[FutureTask]">[FutureTask]</h4></li>
<li><h4 id="[Semaphore]">[Semaphore]</h4></li>
<li><h4 id="[CountDownLatch]">[CountDownLatch]</h4></li>
<li><h4 id="[CyclicBarrier]">[CyclicBarrier]</h4></li>
<li><h4 id="[ReentrantLock]">[ReentrantLock]</h4></li>
<li><h4 id="[Condition]">[Condition]</h4></li>
<li><h4 id="[ReentrantReadWriteLock]">[ReentrantReadWriteLock]</h4></li>
</ul>
<p>提供高性能的线程安全的集合对象、并发场景需要的原子操作类、避免并发时资源冲突的Lock及Condition类</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww1.sinaimg.cn/large/965a04dfgw1euqz5bkuvrj20ix0ga41f.jpg" alt="JDK类库"></p>]]>
    
    </summary>
    
      <category term="JDK" scheme="http://jakezy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://jakezy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 11]]></title>
    <link href="http://jakezy.com/2015/08/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-11/"/>
    <id>http://jakezy.com/2015/08/03/Leetcode刷题记录-11/</id>
    <published>2015-08-03T06:16:58.000Z</published>
    <updated>2015-08-03T16:07:09.454Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></li>
<li><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">Reverse Nodes in k-Group</a></li>
<li><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="external">Rotate Array</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Copy_List_with_Random_Pointer"><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></h2><p>思路：</p>
<p>方法一：一次遍历，hashmap保存结点映射关系</p>
<p>方法二：两次遍历，先复制next，再复制random</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashmap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode, RandomListNode&gt;();</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p是待复制链表，q是复制后链表</span></span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        RandomListNode q = newHead;</span><br><span class="line">        RandomListNode node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若hashmap里已存在该结点，就将其赋值给node结点</span></span><br><span class="line">            <span class="comment">// 否则，新建结点赋值给node，并将p和node对应关系（新旧链表结点的对应关系）加入hashmap</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(p)) &#123;</span><br><span class="line">                node = map.get(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">                map.put(p, node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接入新链表</span></span><br><span class="line">            q.next = node;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制p的random指针</span></span><br><span class="line">            <span class="keyword">if</span> (p.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若hashmap中存在p的random结点，则将其赋值给对应的node结点</span></span><br><span class="line">                <span class="comment">// 否则，新建结点赋值给node.random，并将p.random和node.random对应关系加入hashmap</span></span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(p.random)) &#123;</span><br><span class="line">                    node.random = map.get(p.random);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.random = <span class="keyword">new</span> RandomListNode(p.random.label);</span><br><span class="line">                    map.put(p.random, node.random);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制下一个结点</span></span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次遍历，依次复制各结点，忽略random</span></span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        RandomListNode q = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.next = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次遍历，依次复制各结点的random指针，此时random指向的结点肯定存在</span></span><br><span class="line">        p = head;</span><br><span class="line">        q = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.next.random = <span class="keyword">new</span> RandomListNode(p.random.label);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Reverse_Nodes_in_k-Group"><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">Reverse Nodes in k-Group</a></h2><p>思路：</p>
<p>每一个group执行一次单链表反转操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单链表反转</span></span><br><span class="line">    <span class="comment">// start: 反转部分的前一个结点，end: 反转部分的后一个结点</span></span><br><span class="line">    <span class="comment">// 返回链表尾结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">        ListNode last = start.next;</span><br><span class="line">        ListNode cur = last.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != end) &#123;</span><br><span class="line">            last.next = cur.next;</span><br><span class="line">            cur.next = start.next;</span><br><span class="line">            start.next = cur;</span><br><span class="line">            cur = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode start = dummy;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// i % k == 0 时，i的位置(head)是反转部分的最后一个结点</span></span><br><span class="line">            <span class="comment">// start是group反转后的最后一个结点，即下一个group的前一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                start = reverseList(start, head.next);</span><br><span class="line">                head = start.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Rotate_Array"><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="external">Rotate Array</a></h2><p>思路：</p>
<p>前部分反转，后部分反转，整个数组反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, n - k, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">Copy List with Random Pointer</a></li>
<li><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Reverse Nodes in k-Group</a></li>
<li><a href="https://leetcode.com/problems/rotate-array/">Rotate Array</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 10]]></title>
    <link href="http://jakezy.com/2015/08/01/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-10/"/>
    <id>http://jakezy.com/2015/08/01/Leetcode刷题记录-10/</id>
    <published>2015-08-01T03:10:39.000Z</published>
    <updated>2015-08-01T10:01:44.629Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted List to Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="external">Insertion Sort List</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Merge_k_Sorted_Lists"><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></h2><p>思路：</p>
<ol>
<li>每个链表的头结点入小根堆</li>
<li>取堆顶元素，接入newHead之后，将该元素的下一个结点入堆</li>
<li>循环第二步直到堆空</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;ListNode&gt; ListNodeComparator = <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &gt; right.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left.val == right.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.length,</span><br><span class="line">                ListNodeComparator);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = newHead;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            ListNode temp = heap.poll();</span><br><span class="line">            tail.next = temp;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.add(temp.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Convert_Sorted_List_to_Binary_Search_Tree"><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted List to Binary Search Tree</a></h2><p>思路：</p>
<ol>
<li>找中点</li>
<li>左半部分生成BST</li>
<li>右半部分生成BST</li>
<li>循环1~3</li>
</ol>
<p>优化找中点操作为顺序遍历链表操作，挨个生成树的结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode current;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        TreeNode left = sortedListToBST(start, mid - <span class="number">1</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(current.val);</span><br><span class="line">        current = current.next;</span><br><span class="line">        TreeNode right = sortedListToBST(mid + <span class="number">1</span>, end);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        current = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Insertion_Sort_List"><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="external">Insertion Sort List</a></h2><p>思路：</p>
<p>插入排序：每次将一个元素插入到已排好序的序列中的相应位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);   <span class="comment">// dummy链接已排好序的部分</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从已排好序的部分中查找待插入的位置</span></span><br><span class="line">            ListNode node = dummy;</span><br><span class="line">            <span class="keyword">while</span> (node.next != <span class="keyword">null</span> &amp;&amp; node.next.val &lt;= head.val) &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入结点</span></span><br><span class="line">            ListNode temp = head.next;</span><br><span class="line">            head.next = node.next;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Merge k Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Convert Sorted List to Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/insertion-sort-list/">Insertion Sort List</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 ]]></title>
    <link href="http://jakezy.com/2015/07/30/leetcode/"/>
    <id>http://jakezy.com/2015/07/30/leetcode/</id>
    <published>2015-07-30T08:15:58.000Z</published>
    <updated>2015-08-01T03:09:17.198Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id=""><a href=""></a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="-1"><a href=""></a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="-2"><a href=""></a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 9]]></title>
    <link href="http://jakezy.com/2015/07/30/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-9/"/>
    <id>http://jakezy.com/2015/07/30/Leetcode刷题记录-9/</id>
    <published>2015-07-30T08:15:58.000Z</published>
    <updated>2015-07-30T17:03:40.509Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="external">Delete Node in a Linked List</a></li>
<li><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">Intersection of Two Linked Lists</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Delete_Node_in_a_Linked_List"><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="external">Delete Node in a Linked List</a></h2><p>思路：</p>
<p>交换两前后结点，删除后一结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Palindrome_Linked_List"><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></h2><p>思路：</p>
<ol>
<li>找链表的中间结点，切成两条链表（head, tail）</li>
<li>挨个比较head和tail是否一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode middle = findMiddle(head);</span><br><span class="line">        ListNode tail = middle.next;</span><br><span class="line">        middle.next = <span class="keyword">null</span>;</span><br><span class="line">        tail = reverse(tail);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != tail.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Intersection_of_Two_Linked_Lists"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">Intersection of Two Linked Lists</a></h2><p>思路：</p>
<ol>
<li>求两链表长度，长度差为n</li>
<li>长的链表先走n步</li>
<li>同时遍历两链表，第一个相同的结点即为两链表交点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode p = headA;</span><br><span class="line">        ListNode q = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = lenA - lenB;</span><br><span class="line">        p = n &gt; <span class="number">0</span> ? headA : headB;</span><br><span class="line">        q = n &gt; <span class="number">0</span> ? headB : headA;</span><br><span class="line">        n = n &gt; <span class="number">0</span> ? n : -n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">Delete Node in a Linked List</a></li>
<li><a href="https://leetcode.com/problems/palindrome-linked-list/">Palindrome Linked List</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">Intersection of Two Linked Lists</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 8]]></title>
    <link href="http://jakezy.com/2015/07/29/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-8/"/>
    <id>http://jakezy.com/2015/07/29/Leetcode刷题记录-8/</id>
    <published>2015-07-28T17:54:58.000Z</published>
    <updated>2015-07-30T17:00:16.450Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="external">Partition List</a></li>
<li><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></li>
<li><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="external">Remove Linked List Elements</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Partition_List"><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="external">Partition List</a></h2><p>思路：</p>
<p>维护两个链表，遍历原链表，小于x的接入第一个链表，不小于x的接入第二个链表，再合并两链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        ListNode q = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                p.next = head;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.next = head;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = dummy.next;</span><br><span class="line">        q.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Reorder_List"><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></h2><p>思路：</p>
<p>分成三步：</p>
<ol>
<li>找链表的中间结点，切成两条链表（head, tail）</li>
<li>反转链表tail</li>
<li>合并链表head和tail，合并条件：奇数为head，偶数为tail</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                p.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = tail;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode middle = findMiddle(head);</span><br><span class="line">        ListNode tail = middle.next;</span><br><span class="line">        middle.next = <span class="keyword">null</span>;</span><br><span class="line">        tail = reverse(tail);</span><br><span class="line">        merge(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Remove_Linked_List_Elements"><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="external">Remove Linked List Elements</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode p = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val == val) &#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/partition-list/">Partition List</a></li>
<li><a href="https://leetcode.com/problems/reorder-list/">Reorder List</a></li>
<li><a href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List Elements</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 7]]></title>
    <link href="http://jakezy.com/2015/07/28/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-7/"/>
    <id>http://jakezy.com/2015/07/28/Leetcode刷题记录-7/</id>
    <published>2015-07-28T04:51:53.000Z</published>
    <updated>2015-07-29T17:23:46.978Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="external">Palindrome Partitioning II</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="external">Remove Duplicates from Sorted List</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Palindrome_Partitioning_II"><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="external">Palindrome Partitioning II</a></h2><p>思路：</p>
<p>state: cut[j]表示子串s[0…j]所需要的最小分割次数，isPalindrome[i][j]表示字符串s的子串s[i…j]是否为回文串</p>
<p>function: </p>
<p>initialize: cut[j] = j</p>
<p>answer: cut[j-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cut[j] = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)</span><br><span class="line">                        &amp;&amp; (j - i &lt;= <span class="number">1</span> || isPalindrome[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    isPalindrome[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cut[j] = Math.min(cut[j], cut[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cut[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Remove_Duplicates_from_Sorted_List"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val == p.next.val) &#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Remove_Duplicates_from_Sorted_List_II"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></h2><p>思路：</p>
<p>引入虚节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode p = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span> &amp;&amp; p.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = p.next.val;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val == p.next.next.val) &#123;</span><br><span class="line">                p.next = p.next.next.next;</span><br><span class="line">                <span class="keyword">while</span> (p.next != <span class="keyword">null</span> &amp;&amp; p.next.val == val) &#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/palindrome-partitioning-ii/">Palindrome Partitioning II</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 6]]></title>
    <link href="http://jakezy.com/2015/07/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-6/"/>
    <id>http://jakezy.com/2015/07/27/Leetcode刷题记录-6/</id>
    <published>2015-07-27T04:46:51.000Z</published>
    <updated>2015-07-29T07:32:07.302Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="external">Minimum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="external">Climbing Stairs</a></li>
<li><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="external">Jump Game</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Minimum_Path_Sum"><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="external">Minimum Path Sum</a></h2><p>思路：</p>
<p>state: f[i][j]表示从起点到i,j的最短路径和</p>
<p>function: f[i][j] = min(f[i-1][j], f[i][j-1]) + cost[i][j]</p>
<p>initialize: f[0][0] = cost[0][0], f[0][i] = cost[0][i] + f[0][i-1], f[i][0] = cost[i][0] + f[i-1][0]</p>
<p>answer: f[m-1][n-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        sum[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + sum[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sum[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + sum[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                sum[i][j] = grid[i][j] + Math.min(sum[i - <span class="number">1</span>][j], sum[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Climbing_Stairs"><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="external">Climbing Stairs</a></h2><p>思路：</p>
<p>state: f[i]表示前i个位置跳到i的方案数</p>
<p>function: f[i] = f[i-1] + f[i-2]</p>
<p>initialize: f[0] = 1, f[1] = 2</p>
<p>answer: f[n-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Jump_Game"><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="external">Jump Game</a></h2><p>思路：</p>
<p>state: f[i]表示前i个位置能否跳到第i个位置</p>
<p>function: f[i] = OR(f[j], 0 &lt; j &lt; i &amp;&amp; j能跳到i)</p>
<p>initialize: f[0] = true</p>
<p>answer: f[n-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Dynamic Programming</span></span><br><span class="line">    <span class="comment">// 注：在Leetcode运行会超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] result = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[j] &amp;&amp; nums[j] + j &gt;= i) &#123;</span><br><span class="line">                    result[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a></li>
<li><a href="https://leetcode.com/problems/jump-game/">Jump Game</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 5]]></title>
    <link href="http://jakezy.com/2015/07/26/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-5/"/>
    <id>http://jakezy.com/2015/07/26/Leetcode刷题记录-5/</id>
    <published>2015-07-26T10:03:04.000Z</published>
    <updated>2015-07-29T17:51:53.637Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="external">Triangle</a></li>
<li><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="external">Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="external">Unique Paths II</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Triangle"><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="external">Triangle</a></h2><p>思路：</p>
<p>state: f[i][j]表示从i,j出发到最后一层的最小路径和</p>
<p>function: f[i][j] = min(f[i+1][j], f[i+1][j+1]) + triangle[i][j]</p>
<p>initialize: f[n-1][j] = triangle[n-1][j]</p>
<p>answer: f[0][0]</p>
<p>可省去f[i][j]第一维空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化终点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自底向上递推，更新sum[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                sum[j] = triangle.get(i).get(j) + Math.min(sum[j], sum[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Unique_Paths"><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="external">Unique Paths</a></h2><p>思路：</p>
<p>state: f[i][j]表示从起点到i,j的路径数</p>
<p>function: f[i][j] = f[i-1][j] + f[i][j-1]</p>
<p>initialize: f[0][i] = 1, f[j][0] = 1</p>
<p>answer: f[m-1][n-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Unique_Paths_II"><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="external">Unique Paths II</a></h2><p>思路：</p>
<p>state: f[i][j]表示从起点到i,j的路径数</p>
<p>function: f[i][j] = f[i-1][j] + f[i][j-1]</p>
<p>initialize: f[0][i] = 1, f[j][0] = 1</p>
<p>answer: f[m-1][n-1]</p>
<p>obstacleGrid[i][j]为1时表示路径不通，则grid[i][j] = 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/triangle/">Triangle</a></li>
<li><a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode刷题记录 4]]></title>
    <link href="http://jakezy.com/2015/07/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-4/"/>
    <id>http://jakezy.com/2015/07/25/Leetcode刷题记录-4/</id>
    <published>2015-07-25T11:28:45.000Z</published>
    <updated>2015-07-29T17:51:24.763Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="external">Reverse Linked List</a></li>
<li><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="external">Reverse Linked List II</a></li>
<li><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></li>
<li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></li>
</ul>
<a id="more"></a>
<p><hr></p>
<h2 id="Reverse_Linked_List"><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="external">Reverse Linked List</a></h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">            p = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Reverse_Linked_List_II"><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="external">Reverse Linked List II</a></h2><p>思路：</p>
<p>m的前一个节点作为头节点，使用头插法插入m~n之间的节点，最后将m的下一个节点调整为n之后的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode start = fakeHead;</span><br><span class="line">        fakeHead.next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode end = start.next;</span><br><span class="line">        ListNode p = start.next.next;</span><br><span class="line">        ListNode q = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q.next = start.next;</span><br><span class="line">            start.next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        end.next = p;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Linked_List_Cycle"><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h2><p>思路：</p>
<p>快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Linked_List_Cycle_II"><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></h2><p>思路：</p>
<ol>
<li>快慢指针查找相遇点</li>
<li>慢指针回到起点，快慢指针每次移动一步</li>
<li>快慢指针再次相遇点即为链表环入口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List</a></li>
<li><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Reverse Linked List II</a></li>
<li><a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle</a></li>
<li><a href="https://leetcode.com/problems/linked-list-cycle-ii/">Linked List Cycle II</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Leetcode" scheme="http://jakezy.com/tags/Leetcode/"/>
    
      <category term="Leetcode" scheme="http://jakezy.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>